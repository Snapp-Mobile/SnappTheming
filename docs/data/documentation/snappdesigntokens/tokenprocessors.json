{"schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/snappdesigntokens\/tokenprocessors"]}],"topicSections":[{"anchor":"Processor-Protocol","title":"Processor Protocol","identifiers":["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/TokenProcessor"]},{"anchor":"Combining-Processors","title":"Combining Processors","identifiers":["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/CombineProcessor"]},{"anchor":"Alias-Resolution","title":"Alias Resolution","identifiers":["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ResolveAliasesTokenProcessor"]},{"anchor":"Structure-Transformation","title":"Structure Transformation","identifiers":["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/FlattenProcessor","doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/SkipKeysProcessor"]},{"anchor":"Dimension-Processing","title":"Dimension Processing","identifiers":["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueEvaluationProcessor","doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueConversionProcessor"]},{"anchor":"File-Handling","title":"File Handling","identifiers":["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/FileCachingProcessor"]},{"anchor":"Related-Documentation","title":"Related Documentation","identifiers":["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ExpressionEvaluation","doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/Token","doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValue"]}],"abstract":[{"text":"Transform design token trees through composable pipeline operations.","type":"text"}],"metadata":{"roleHeading":"API Collection","role":"collectionGroup","modules":[{"name":"SnappDesignTokens"}],"title":"Token Processors"},"kind":"article","primaryContentSections":[{"kind":"content","content":[{"text":"Overview","anchor":"Overview","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Token processors provide a modular architecture for transforming design token trees after parsing. Each processor performs a specific transformation—resolving aliases, evaluating expressions, converting units, or flattening hierarchies. Processors implement the "},{"isActive":true,"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/TokenProcessor","type":"reference"},{"type":"text","text":" protocol and can be chained sequentially to build complex transformation pipelines."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The processing pipeline follows a typical sequence: parse JSON → resolve token aliases → evaluate mathematical expressions → convert dimension units → flatten nested structures. Each step transforms the token tree, passing its output to the next processor. This composable design enables flexible token transformations while keeping individual processors simple and focused."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"All processors support Swift concurrency with "},{"code":"async","type":"codeVoice"},{"text":"\/","type":"text"},{"code":"throws","type":"codeVoice"},{"text":" signatures and ","type":"text"},{"code":"Sendable","type":"codeVoice"},{"text":" conformance, enabling safe concurrent token processing in modern Swift applications.","type":"text"}],"type":"paragraph"},{"text":"When to Use Processors","anchor":"When-to-Use-Processors","level":3,"type":"heading"},{"inlineContent":[{"text":"Use token processors when you need to:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Convert token aliases into their actual values before exporting","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Evaluate mathematical expressions in dimension tokens to produce computed values","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Standardize all dimensions to a single unit (e.g., convert everything to "},{"code":"rem","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Flatten nested token groups into flat key-value structures","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Filter out internal or deprecated tokens before delivery","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Cache processed results for performance optimization","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Built-in Processors","anchor":"Built-in-Processors","level":2,"type":"heading"},{"inlineContent":[{"text":"SnappDesignTokens provides several processors for common token transformations.","type":"text"}],"type":"paragraph"},{"text":"Resolve Aliases","anchor":"Resolve-Aliases","level":3,"type":"heading"},{"inlineContent":[{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ResolveAliasesTokenProcessor","isActive":true,"type":"reference"},{"text":" resolves all token references (","type":"text"},{"type":"codeVoice","code":"{group.token}"},{"text":" syntax) to their actual values, following reference chains until reaching concrete values.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Tokens with aliases: { \"base\": { \"color\": \"#FF0000\" }, \"theme\": { \"primary\": \"{base.color}\" } }","","let processor: TokenProcessor = .resolveAliases","let resolved = try await processor.process(token)","\/\/ Result: { \"base\": { \"color\": \"#FF0000\" }, \"theme\": { \"primary\": \"#FF0000\" } }"],"type":"codeListing"},{"inlineContent":[{"text":"This processor traverses the entire token tree recursively, replacing all ","type":"text"},{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/CompositeTokenValue\/alias(_:)","isActive":true,"type":"reference"},{"text":" references with their resolved values. If an alias references another alias, resolution continues until reaching a concrete value. Circular references are detected and reported as errors.","type":"text"}],"type":"paragraph"},{"text":"Flatten Hierarchy","type":"heading","level":3,"anchor":"Flatten-Hierarchy"},{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/FlattenProcessor"},{"text":" converts nested token groups into a flat dictionary structure, combining group paths into token keys. This is useful for exporting tokens to platforms that don’t support hierarchical organization.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Nested tokens: { \"colors\": { \"brand\": { \"primary\": \"#FF0000\" } } }","","let processor: TokenProcessor = .flatten(pathConversionStrategy: .dotSeparated)","let flattened = try await processor.process(token)","\/\/ Result: { \"colors.brand.primary\": \"#FF0000\" }"],"type":"codeListing"},{"inlineContent":[{"text":"The processor supports three path conversion strategies:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Dot-separated","type":"text"}]},{"text":" (","type":"text"},{"type":"codeVoice","code":".dotSeparated"},{"text":"): Joins paths with periods (","type":"text"},{"type":"codeVoice","code":"colors.brand.primary"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Snake case","type":"text"}],"type":"strong"},{"text":" (","type":"text"},{"code":".convertToSnakeCase","type":"codeVoice"},{"text":"): Converts to underscore notation (","type":"text"},{"code":"colors_brand_primary","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Camel case","type":"text"}],"type":"strong"},{"text":" (","type":"text"},{"code":".convertToCamelCase","type":"codeVoice"},{"text":"): Converts to camel case (","type":"text"},{"code":"colorsBrandPrimary","type":"codeVoice"},{"text":")","type":"text"}]}]}],"type":"unorderedList"},{"code":["\/\/ Using different strategies","let snakeCase: TokenProcessor = .flatten(pathConversionStrategy: .convertToSnakeCase)","\/\/ Produces: colors_brand_primary","","let camelCase: TokenProcessor = .flatten(pathConversionStrategy: .convertToCamelCase)","\/\/ Produces: colorsBrandPrimary"],"syntax":"swift","type":"codeListing"},{"text":"Evaluate Expressions","anchor":"Evaluate-Expressions","type":"heading","level":3},{"inlineContent":[{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueEvaluationProcessor","type":"reference","isActive":true},{"text":" evaluates mathematical expressions in dimension tokens, computing constant values from formulas. See ","type":"text"},{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ExpressionEvaluation","type":"reference","isActive":true},{"text":" for detailed expression syntax and capabilities.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Tokens with expressions: { \"spacing\": \"16px * 1.5\", \"margin\": \"8px + 4px\" }","","let processor: TokenProcessor = .arithmeticalEvaluation","let evaluated = try await processor.process(token)","\/\/ Result: { \"spacing\": \"24px\", \"margin\": \"12px\" }"]},{"type":"paragraph","inlineContent":[{"text":"This processor supports two evaluation engines: ","type":"text"},{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/NSExpressionDimensionEvaluator","type":"reference","isActive":true},{"text":" (default) and ","type":"text"},{"isActive":true,"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ArithmeticalExpressionEvaluator","type":"reference"},{"type":"text","text":". Both handle standard arithmetic operations ("},{"code":"+","type":"codeVoice"},{"text":", ","type":"text"},{"code":"-","type":"codeVoice"},{"type":"text","text":", "},{"code":"*","type":"codeVoice"},{"type":"text","text":", "},{"code":"\/","type":"codeVoice"},{"text":"), unit conversion, and nested parentheses.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Using custom evaluator","let customProcessor: TokenProcessor = .dimensionValueEvaluation(","    using: ArithmeticalExpressionEvaluator()",")"]},{"type":"paragraph","inlineContent":[{"text":"The processor recursively evaluates all dimension expressions in the token tree, including those in composite token types like ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/TypographyValue"},{"text":" (fontSize, letterSpacing).","type":"text"}]},{"text":"Convert Units","type":"heading","anchor":"Convert-Units","level":3},{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueConversionProcessor"},{"text":" converts all dimension values to a target unit, standardizing mixed-unit token sets.","type":"text"}],"type":"paragraph"},{"code":["\/\/ Tokens with mixed units: { \"spacing\": \"16px\", \"margin\": \"1rem\", \"padding\": \"0.5em\" }","","let processor: TokenProcessor = .dimensionValueConversion(targetUnit: .rem)","let converted = try await processor.process(token)","\/\/ Result: { \"spacing\": \"1rem\", \"margin\": \"1rem\", \"padding\": \"0.5rem\" }"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The processor uses "},{"type":"reference","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueConverter","isActive":true},{"type":"text","text":" for unit calculations, applying conversion ratios defined in the converter. Both constant dimensions and expression elements are converted."}]},{"syntax":"swift","code":["\/\/ Convert to pixels","let pxProcessor: TokenProcessor = .dimensionValueConversion(targetUnit: .px)","","\/\/ Using custom converter","let customProcessor: TokenProcessor = .dimensionValueConversion(","    using: CustomConverter(baseFontSize: 18.0),","    targetUnit: .rem",")"],"type":"codeListing"},{"text":"Skip Keys","type":"heading","anchor":"Skip-Keys","level":3},{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/SkipKeysProcessor"},{"type":"text","text":" removes specified keys from the root token group, filtering out unwanted metadata or internal tokens before export."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Tokens with metadata: { \"$schema\": \"...\", \"$metadata\": {...}, \"colors\": {...} }","","let processor: TokenProcessor = .skipKeys(\"$schema\", \"$metadata\", \"_internal\")","let filtered = try await processor.process(token)","\/\/ Result: { \"colors\": {...} }"]},{"inlineContent":[{"text":"This processor only processes the root level token group. Nested groups are unaffected. Use variadic string arguments or pass an array of key names.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Using array syntax","let keys = [\"$schema\", \"$metadata\", \"$deprecated\"]","let processor: TokenProcessor = .skipKeys(keys)"],"type":"codeListing"},{"text":"Cache Files","anchor":"Cache-Files","level":3,"type":"heading"},{"inlineContent":[{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/FileCachingProcessor","type":"reference","isActive":true},{"text":" downloads and caches remote file assets referenced in file tokens, replacing remote URLs with local file paths.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let manager = AssetsManager(themeName: \"myTheme\")","let processor = FileCachingProcessor(assetsManager: manager)","let cached = try await processor.process(token)","\/\/ File tokens now reference local cached files"],"type":"codeListing"},{"inlineContent":[{"text":"This processor is typically used internally by the framework when loading tokens with file references. File downloads are asynchronous, and failed downloads are logged without stopping processing. The original token is preserved if download fails.","type":"text"}],"type":"paragraph"},{"text":"Combining Processors","anchor":"Combining-Processors","level":2,"type":"heading"},{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/CombineProcessor"},{"text":" chains multiple processors sequentially, executing each in order and passing the output of one as input to the next.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let pipeline: TokenProcessor = .combine(","    .resolveAliases,","    .arithmeticalEvaluation,","    .dimensionValueConversion(targetUnit: .rem),","    .flatten(pathConversionStrategy: .dotSeparated)",")","let result = try await pipeline.process(token)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Processor order matters because each transformation builds on previous results:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Resolve aliases first","type":"text"}],"type":"strong"},{"text":" – Later processors need actual values, not references","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Evaluate expressions","type":"text"}],"type":"strong"},{"text":" – Produces concrete values for unit conversion","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Convert units"}]},{"text":" – Standardizes dimensions before flattening","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Flatten last","type":"text"}],"type":"strong"},{"text":" – Works on fully resolved, evaluated token tree","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"syntax":"swift","code":["\/\/ Using combine method syntax","let pipeline = ResolveAliasesTokenProcessor.resolveAliases","    .combine(.arithmeticalEvaluation)","    .combine(.flatten())"],"type":"codeListing"},{"text":"Error Handling","anchor":"Error-Handling","type":"heading","level":3},{"inlineContent":[{"text":"Any processor in the chain can throw errors, stopping pipeline execution immediately. Handle errors when processing to catch issues like circular alias references or invalid expressions.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["do {","    let result = try await pipeline.process(token)","    \/\/ Process successful result","} catch let error as AliasResolutionError {","    \/\/ Handle alias resolution failures","} catch let error as ExpressionEvaluationError {","    \/\/ Handle expression evaluation failures","} catch {","    \/\/ Handle other processing errors","}"],"type":"codeListing"},{"text":"Custom Processors","anchor":"Custom-Processors","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Create custom processors by conforming to ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/TokenProcessor"},{"text":" protocol. Processors must implement a single async method that transforms a token tree.","type":"text"}]},{"syntax":"swift","code":["struct FilterDeprecatedProcessor: TokenProcessor {","    func process(_ token: Token) async throws -> Token {","        token.map { element in","            guard case .group(var group) = element else {","                return element","            }","            \/\/ Remove tokens with $deprecated property","            group = group.filter { _, value in","                \/\/ Custom filtering logic","                return !isDeprecated(value)","            }","            return .group(group)","        }","    }","}"],"type":"codeListing"},{"text":"Implementation Guidelines","anchor":"Implementation-Guidelines","type":"heading","level":3},{"inlineContent":[{"text":"When implementing custom processors:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Immutability"}]},{"type":"text","text":": Never mutate the input token. Always return a new transformed token."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Recursion","type":"text"}],"type":"strong"},{"type":"text","text":": Use "},{"isActive":true,"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/Token\/map(_:)","type":"reference"},{"text":" to recursively traverse the token tree.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Sendable","type":"text"}]},{"text":": Ensure all captured values are thread-safe for Swift concurrency.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Performance","type":"text"}],"type":"strong"},{"text":": Minimize allocations and avoid unnecessary tree traversals.","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Error handling","type":"text"}],"type":"strong"},{"text":": Throw descriptive errors for transformation failures.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["struct ScaleDimensionsProcessor: TokenProcessor {","    let scale: Double","","    func process(_ token: Token) async throws -> Token {","        guard scale > 0 else {","            throw ProcessingError.invalidScale(scale)","        }","","        return token.map { element in","            guard case .value(.dimension(.constant(let dimension))) = element else {","                return element","            }","","            let scaled = DimensionValue(","                value: dimension.value * scale,","                unit: dimension.unit","            )","            return .value(.dimension(.constant(scaled)))","        }","    }","}"]},{"text":"Common Patterns","anchor":"Common-Patterns","level":2,"type":"heading"},{"text":"Standard Export Pipeline","anchor":"Standard-Export-Pipeline","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Most export workflows follow this pattern: resolve references, evaluate calculations, standardize units, flatten structure.","type":"text"}]},{"syntax":"swift","code":["let exportPipeline: TokenProcessor = .combine(","    .skipKeys(\"$schema\", \"$metadata\"),","    .resolveAliases,","    .arithmeticalEvaluation,","    .dimensionValueConversion(targetUnit: .rem),","    .flatten(pathConversionStrategy: .dotSeparated)",")","","let tokens = try await TokenLoader.load(from: url)","let exported = try await exportPipeline.process(tokens)"],"type":"codeListing"},{"text":"Conditional Processing","anchor":"Conditional-Processing","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"Apply processors conditionally based on token content or platform requirements."}],"type":"paragraph"},{"code":["func createPlatformProcessor(platform: Platform) -> TokenProcessor {","    let baseProcessors: [TokenProcessor] = [","        .resolveAliases,","        .arithmeticalEvaluation","    ]","","    switch platform {","    case .web:","        return .combine(baseProcessors + [","            .dimensionValueConversion(targetUnit: .rem),","            .flatten(pathConversionStrategy: .dotSeparated)","        ])","    case .ios:","        return .combine(baseProcessors + [","            .dimensionValueConversion(targetUnit: .pt),","            .flatten(pathConversionStrategy: .convertToCamelCase)","        ])","    case .android:","        return .combine(baseProcessors + [","            .dimensionValueConversion(targetUnit: .dp),","            .flatten(pathConversionStrategy: .convertToSnakeCase)","        ])","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Testing Processors","anchor":"Testing-Processors","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"Test processors independently before combining them into pipelines."}],"type":"paragraph"},{"syntax":"swift","code":["func testResolveAliases() async throws {","    let input = Token.group([","        \"base\": .group([\"color\": .value(.color(.red))]),","        \"theme\": .group([\"primary\": .alias(\"base.color\")])","    ])","","    let processor: TokenProcessor = .resolveAliases","    let result = try await processor.process(input)","","    guard case .group(let groups) = result,","          case .group(let theme) = groups[\"theme\"],","          case .value(.color(.red)) = theme[\"primary\"] else {","        XCTFail(\"Alias not resolved correctly\")","        return","    }","}"],"type":"codeListing"},{"text":"Best Practices","anchor":"Best-Practices","level":2,"type":"heading"},{"text":"Processor Ordering","anchor":"Processor-Ordering","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"Follow this general order for maximum effectiveness:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Filter unwanted keys","type":"text"}],"type":"strong"},{"type":"text","text":" ("},{"isActive":true,"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/SkipKeysProcessor","type":"reference"},{"type":"text","text":") – Remove metadata early"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Resolve aliases","type":"text"}],"type":"strong"},{"text":" (","type":"text"},{"isActive":true,"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ResolveAliasesTokenProcessor","type":"reference"},{"text":") – Eliminate references before computation","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Evaluate expressions","type":"text"}],"type":"strong"},{"type":"text","text":" ("},{"isActive":true,"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueEvaluationProcessor","type":"reference"},{"type":"text","text":") – Compute values before conversion"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Convert units","type":"text"}]},{"text":" (","type":"text"},{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueConversionProcessor","type":"reference","isActive":true},{"text":") – Standardize before flattening","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Flatten hierarchy"}],"type":"strong"},{"type":"text","text":" ("},{"isActive":true,"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/FlattenProcessor","type":"reference"},{"type":"text","text":") – Final structural transformation"}]}]}],"type":"orderedList"},{"text":"Performance Considerations","anchor":"Performance-Considerations","level":3,"type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Cache pipeline results"}]},{"text":": Reuse processed tokens instead of re-processing","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Avoid redundant processors","type":"text"}],"type":"strong"},{"type":"text","text":": Don’t include processors that won’t transform anything"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Process once","type":"text"}],"type":"strong"},{"text":": Combine multiple transformations into single pipeline rather than applying processors separately","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Profile custom processors"}],"type":"strong"},{"text":": Measure performance impact of complex transformations","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Error Recovery","type":"heading","anchor":"Error-Recovery","level":3},{"inlineContent":[{"text":"Design processors to handle partial failures gracefully when appropriate.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct TolerantProcessor: TokenProcessor {","    func process(_ token: Token) async throws -> Token {","        token.map { element in","            do {","                return try transform(element)","            } catch {","                \/\/ Log error but preserve original token","                logger.warning(\"Failed to transform token: \\(error)\")","                return element","            }","        }","    }","}"],"type":"codeListing"}]}],"hierarchy":{"paths":[["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens"]]},"seeAlsoSections":[{"anchor":"Advanced-Features","title":"Advanced Features","generated":true,"identifiers":["doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ExpressionEvaluation"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/TokenProcessors"},"sections":[],"references":{"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/Token":{"kind":"symbol","url":"\/documentation\/snappdesigntokens\/token","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"Token"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/Token","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Token"}],"title":"Token","abstract":[{"type":"text","text":"Represents a design token as defined by the DTCG specification."}],"role":"symbol"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/SkipKeysProcessor":{"url":"\/documentation\/snappdesigntokens\/skipkeysprocessor","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"SkipKeysProcessor"}],"abstract":[{"text":"Processor that removes specified keys from token groups.","type":"text"}],"kind":"symbol","title":"SkipKeysProcessor","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SkipKeysProcessor"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/SkipKeysProcessor"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/TokenProcessor":{"url":"\/documentation\/snappdesigntokens\/tokenprocessor","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"TokenProcessor"}],"abstract":[{"text":"Protocol for transforming token trees.","type":"text"}],"kind":"symbol","title":"TokenProcessor","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"TokenProcessor"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/TokenProcessor"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/ArithmeticalExpressionEvaluator":{"navigatorTitle":[{"kind":"identifier","text":"ArithmeticalExpressionEvaluator"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ArithmeticalExpressionEvaluator"}],"title":"ArithmeticalExpressionEvaluator","abstract":[{"type":"text","text":"Evaluates dimension formulas using custom arithmetic parser."}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ArithmeticalExpressionEvaluator","kind":"symbol","url":"\/documentation\/snappdesigntokens\/arithmeticalexpressionevaluator","role":"symbol","type":"topic"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/CombineProcessor":{"type":"topic","url":"\/documentation\/snappdesigntokens\/combineprocessor","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"CombineProcessor"}],"abstract":[{"type":"text","text":"Processor that chains multiple processors sequentially."}],"kind":"symbol","title":"CombineProcessor","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"CombineProcessor"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/CombineProcessor"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens":{"images":[{"type":"icon","identifier":"logo_tokens.png"}],"title":"SnappDesignTokens","abstract":[{"type":"text","text":"Framework for parsing and processing "},{"type":"codeVoice","code":"DTCG"},{"text":" tokens.","type":"text"}],"url":"\/documentation\/snappdesigntokens","kind":"symbol","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens","role":"collection","type":"topic"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/CompositeTokenValue/alias(_:)":{"fragments":[{"text":"case","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"alias"},{"text":"(","kind":"text"},{"preciseIdentifier":"s:17SnappDesignTokens9TokenPathV","text":"TokenPath","kind":"typeIdentifier"},{"text":")","kind":"text"}],"title":"CompositeTokenValue.alias(_:)","abstract":[{"type":"text","text":"Token alias referencing another token’s value."}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/CompositeTokenValue\/alias(_:)","url":"\/documentation\/snappdesigntokens\/compositetokenvalue\/alias(_:)","kind":"symbol","role":"symbol","type":"topic"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/DimensionValueConverter":{"type":"topic","url":"\/documentation\/snappdesigntokens\/dimensionvalueconverter","role":"symbol","navigatorTitle":[{"text":"DimensionValueConverter","kind":"identifier"}],"abstract":[{"text":"Protocol for converting dimension values between units.","type":"text"}],"kind":"symbol","title":"DimensionValueConverter","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DimensionValueConverter","kind":"identifier"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueConverter"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/DimensionValueConversionProcessor":{"kind":"symbol","url":"\/documentation\/snappdesigntokens\/dimensionvalueconversionprocessor","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DimensionValueConversionProcessor"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueConversionProcessor","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DimensionValueConversionProcessor"}],"title":"DimensionValueConversionProcessor","abstract":[{"text":"Processor that converts dimension values to a target unit.","type":"text"}],"role":"symbol"},"operators.png":{"alt":null,"type":"image","identifier":"operators.png","variants":[{"url":"\/images\/snappdesigntokens.SnappDesignTokens\/operators.png","traits":["1x","light"]},{"traits":["2x","light"],"url":"\/images\/snappdesigntokens.SnappDesignTokens\/operators@2x.png"},{"url":"\/images\/snappdesigntokens.SnappDesignTokens\/operators@3x.png","traits":["3x","light"]},{"traits":["1x","dark"],"url":"\/images\/snappdesigntokens.SnappDesignTokens\/operators~dark.png"},{"traits":["2x","dark"],"url":"\/images\/snappdesigntokens.SnappDesignTokens\/operators~dark@2x.png"},{"traits":["3x","dark"],"url":"\/images\/snappdesigntokens.SnappDesignTokens\/operators~dark@3x.png"}]},"logo_tokens.png":{"alt":null,"type":"image","identifier":"logo_tokens.png","variants":[{"url":"\/images\/snappdesigntokens.SnappDesignTokens\/logo_tokens.png","traits":["1x","light"]},{"url":"\/images\/snappdesigntokens.SnappDesignTokens\/logo_tokens@2x.png","traits":["2x","light"]},{"url":"\/images\/snappdesigntokens.SnappDesignTokens\/logo_tokens@3x.png","traits":["3x","light"]}]},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/FileCachingProcessor":{"url":"\/documentation\/snappdesigntokens\/filecachingprocessor","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"FileCachingProcessor","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/FileCachingProcessor","navigatorTitle":[{"kind":"identifier","text":"FileCachingProcessor"}],"title":"FileCachingProcessor","abstract":[{"text":"Processor that downloads and caches remote file token assets.","type":"text"}],"role":"symbol"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/DimensionValueEvaluationProcessor":{"navigatorTitle":[{"text":"DimensionValueEvaluationProcessor","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DimensionValueEvaluationProcessor","kind":"identifier"}],"title":"DimensionValueEvaluationProcessor","abstract":[{"text":"Processor that evaluates dimension expressions to constant values.","type":"text"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValueEvaluationProcessor","url":"\/documentation\/snappdesigntokens\/dimensionvalueevaluationprocessor","kind":"symbol","role":"symbol","type":"topic"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/ResolveAliasesTokenProcessor":{"navigatorTitle":[{"text":"ResolveAliasesTokenProcessor","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"ResolveAliasesTokenProcessor"}],"title":"ResolveAliasesTokenProcessor","abstract":[{"type":"text","text":"Processor that resolves all token aliases to their actual values."}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ResolveAliasesTokenProcessor","kind":"symbol","url":"\/documentation\/snappdesigntokens\/resolvealiasestokenprocessor","role":"symbol","type":"topic"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/ExpressionEvaluation":{"url":"\/documentation\/snappdesigntokens\/expressionevaluation","type":"topic","role":"collectionGroup","images":[{"type":"icon","identifier":"operators.png"}],"abstract":[{"type":"text","text":"Evaluate mathematical expressions in dimension token values."}],"kind":"article","title":"Expression Evaluation","identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/ExpressionEvaluation"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/Token/map(_:)":{"url":"\/documentation\/snappdesigntokens\/token\/map(_:)","type":"topic","role":"symbol","abstract":[{"text":"Transforms all tokens in the tree using the provided closure.","type":"text"}],"kind":"symbol","title":"map(_:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"map","kind":"identifier"},{"text":"((","kind":"text"},{"text":"_","kind":"externalParam"},{"kind":"text","text":" "},{"kind":"internalParam","text":"element"},{"kind":"text","text":": "},{"preciseIdentifier":"s:17SnappDesignTokens5TokenO","kind":"typeIdentifier","text":"Token"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"preciseIdentifier":"s:17SnappDesignTokens5TokenO","kind":"typeIdentifier","text":"Token"},{"kind":"text","text":") "},{"text":"rethrows","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"Token","kind":"typeIdentifier","preciseIdentifier":"s:17SnappDesignTokens5TokenO"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/Token\/map(_:)"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/FlattenProcessor":{"url":"\/documentation\/snappdesigntokens\/flattenprocessor","type":"topic","role":"symbol","navigatorTitle":[{"text":"FlattenProcessor","kind":"identifier"}],"abstract":[{"type":"text","text":"Processor that flattens nested token groups into a single-level dictionary."}],"kind":"symbol","title":"FlattenProcessor","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FlattenProcessor","kind":"identifier"}],"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/FlattenProcessor"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/NSExpressionDimensionEvaluator":{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/NSExpressionDimensionEvaluator","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"NSExpressionDimensionEvaluator"}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"NSExpressionDimensionEvaluator"}],"url":"\/documentation\/snappdesigntokens\/nsexpressiondimensionevaluator","kind":"symbol","abstract":[{"text":"Type alias for the default NSExpression-based dimension evaluator.","type":"text"}],"role":"symbol","title":"NSExpressionDimensionEvaluator"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/DimensionValue":{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/DimensionValue","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"DimensionValue"}],"type":"topic","navigatorTitle":[{"text":"DimensionValue","kind":"identifier"}],"url":"\/documentation\/snappdesigntokens\/dimensionvalue","kind":"symbol","abstract":[{"type":"text","text":"Represents a dimension token value for UI measurements."}],"role":"symbol","title":"DimensionValue"},"doc://snappdesigntokens.SnappDesignTokens/documentation/SnappDesignTokens/TypographyValue":{"identifier":"doc:\/\/snappdesigntokens.SnappDesignTokens\/documentation\/SnappDesignTokens\/TypographyValue","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"TypographyValue","kind":"identifier"}],"type":"topic","navigatorTitle":[{"text":"TypographyValue","kind":"identifier"}],"url":"\/documentation\/snappdesigntokens\/typographyvalue","kind":"symbol","abstract":[{"type":"text","text":"Represents a complete typographic style."}],"role":"symbol","title":"TypographyValue"}}}