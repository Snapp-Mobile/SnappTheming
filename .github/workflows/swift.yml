# This workflow will test a Swift project
 # For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-swift

 name: Package Test
 env:
   DESTINATION: 'platform=macOS,variant=Mac Catalyst,name=My Mac'
   SCHEME: 'SnappTheming-Package'
   WORKSPACE_PATH: '.swiftpm/xcode/package.xcworkspace'
   COVERAGE_REPORT_PATH: './coverage/coverage.xcresult'
 on:
   push:
     branches: [ "main" ]
   pull_request:
     branches: [ "main" ]

 jobs:
   build:

     runs-on: macos-latest

     steps:
     - uses: actions/checkout@v2
     - name: List Xcode installations
       run: sudo ls -1 /Applications | grep "Xcode"
     - name: Select Xcode 16.2
       run: sudo xcode-select -s /Applications/Xcode_16.2.app/Contents/Developer

     - name: Run Swift Tests with Coverage
       run: |
         CODECOV_PATH=$(swift test --enable-code-coverage --show-codecov-path | tail -n 1)
         echo "CODECOV_PATH=$CODECOV_PATH" >> $GITHUB_ENV

     - name: Extract Overall Code Coverage
       run: |
         if [ ! -f "$CODECOV_PATH" ]; then
           echo "‚ùå Code coverage file not found!"
           exit 1
         fi
     
         # Extract total line coverage percentage
         OVERALL_COVERAGE=$(jq '.data[0].totals.lines.percent' "$CODECOV_PATH")
     
         echo "üõ°Ô∏è Overall Code Coverage: ${OVERALL_COVERAGE}%"
         echo "Overall Coverage: ${OVERALL_COVERAGE}%" > pr_coverage_summary.txt
     
         # Save coverage as an environment variable for later use
         echo "OVERALL_COVERAGE=$OVERALL_COVERAGE" >> $GITHUB_EN

     - name: Swift Test
       run: |
         swift test -v --enable-swift-testing --enable-code-coverage
         OVERALL_COVERAGE=$(cat /Users/runner/work/SnappTheming/SnappTheming/.build/arm64-apple-macosx/debug/codecov/SnappTheming.json | jq '.data[0].totals.lines.percent')
         echo "Overall Code Coverage: ${OVERALL_COVERAGE}%"

#     - name: Merge Coverage Data
#       run: |
#         xcrun llvm-profdata merge -sparse .build/debug/code-*.profraw -o .build/debug/default.profdata
#
#     - name: Extract Code Coverage
#       run: |
#         TARGET_EXECUTABLE=$(find .build/debug -type f -perm +111 | grep -E     "(Tests|xctest|test)" || true)
#
#         if [ -z "$TARGET_EXECUTABLE" ]; then
#           echo "‚ö†Ô∏è Error: Test executable not found!"
#           exit 1
#         fi
#
#         xcrun llvm-cov report "$TARGET_EXECUTABLE" \
#           -instr-profile .build/debug/default.profdata \
#           > coverage-report.txt
#
#         tail -n 5 coverage-report.txt > pr_coverage_summary.txt

#     - name: Test
#       run: |
#         xcodebuild test \
#            -workspace "${{env.WORKSPACE_PATH}}" \
#            -scheme "${{env.SCHEME}}" \
#            -destination "${{env.DESTINATION}}" \
#            -enableCodeCoverage YES \
#            -resultBundlePath '${{env.COVERAGE_REPORT_PATH}}' \
#            -skipMacroValidation \
#            -quiet

#     - name: Comment on Pull Request
#       if: github.event_name == 'pull_request'
#       uses: actions/github-script@v6
#       with:
#         script: |
#            const fs = require('fs');
#            const coverageOutput = fs.readFileSync('pr_coverage_summary.txt', 'utf8');
#
#            const newComment = `
#            ### üõ°Ô∏è Code Coverage Report
#            
#            \`\`\`
#            ${coverageOutput}
#            \`\`\`
#
#            _Generated by GitHub Actions._
#            `;
#
#            // Fetch existing comments
#            const comments = await github.rest.issues.listComments({
#              owner: context.repo.owner,
#              repo: context.repo.repo,
#              issue_number: context.payload.pull_request.number,
#            });
#
#            // Identify and delete previous bot comments
#            const botComments = comments.data.filter(comment =>
#              comment.body.includes("### üõ°Ô∏è Code Coverage Report")
#            );
#
#            for (const botComment of botComments) {
#              await github.rest.issues.deleteComment({
#                owner: context.repo.owner,
#                repo: context.repo.repo,
#                comment_id: botComment.id,
#              });
#            }
#
#            // Create a comment on the pull request
#            await github.rest.issues.createComment({
#              issue_number: context.payload.pull_request.number,
#              owner: context.repo.owner,
#              repo: context.repo.repo,
#              body: newComment,
#            });
